#pragma config(Motor,  port10,           frontRight,    tmotorNormal, openLoop)
#pragma config(Motor,  port2,           backRight,     tmotorNormal, openLoop)
#pragma config(Motor,  port1,           frontLeft,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           backLeft,      tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition) // "Competition" or "OFF"
#pragma autonomousDuration(15) // 15 sec
#pragma userControlDuration(105) // 1 min 45 sec

#include “Vex_Competition_Includes.c”

/***** Settings *****/

int deadzonesize = 15;

/***** Utility *****/

int round(float x) {
   return (f>0)?(int)(f+0.5):(int)(f - 0.5);
}

float deadzone(int input) {
  if (abs(input)<deadzonesize) {
    return 0;
  }

  float out = input - deadzonesize; // Adjust so that the values come out of the deadzone at 0
  out = out * 128/(128-deadzonesize); // Rescale so that the max value can still be reached


  return out;
	//return abs(input) > deadzonesize ? ((input - deadzonesize)) : 0; // * 1/(1/deadzonesize)
}

int improveInput(int input) {
  return round(pow(deadzone(input)/128, 3) * 128);
}

/***** Main Control *****/

void pre_autonomous()
{
  //Place pre-autonomous code here
}

task autonomous()
{
  //Place autonomous code here
}

task usercontrol()
{
  int X2 = 0, Y1 = 0, X1 = 0;
  while(true) {
    Y1 = improveInput(vexRT[Ch3]);
    X1 = improveInput(vexRT[Ch4]);
    X2 = improveInput(vexRT[Ch1]);

    // map inputs to mecanum wheels
    motor[frontRight] = Y1 - X2 - X1;
    motor[backRight] =  Y1 - X2 + X1;
    motor[frontLeft] = Y1 + X2 + X1;
    motor[backLeft] =  Y1 + X2 - X1;
  }
}
