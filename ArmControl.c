#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           baseleft,      tmotorVex393_HBridge, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port2,           midleft,       tmotorVex393_MC29, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backright,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backleft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frontleft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontright,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           wrist,         tmotorVex393_MC29, PIDControl, encoderPort, I2C_3)
#pragma config(Motor,  port9,           midright,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          baseright,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(OFF) // "Competition" or "OFF"
#pragma autonomousDuration(15) // 15 sec
#pragma userControlDuration(105) // 1 min 45 sec

#include "Vex_Competition_Includes.c"

/***** Settings *****/

int deadzonesize = 15;

int valb=0;
int valm=0;
int valw=0;

/***** Utility *****/

void moveTo(tMotor mot, int target) {
	setMotorTarget(mot, target, 127, true);
}

void moveToWait(tMotor mot, int target) {
	moveTo(mot, target);

	// Wait for motor to move
	while(!getMotorTargetCompleted(mot)) {
	   wait1Msec(5);
	 }
}

//int round(float f) {
//   return (f>0)?(int)(f+0.5):(int)(f - 0.5);
//}

float deadzone(int input) {
  if (abs(input)<deadzonesize) {
    return 0;
  }

  float out = input - deadzonesize; // Adjust so that the values come out of the deadzone at 0
  out = out * 128/(128-deadzonesize); // Rescale so that the max value can still be reached


  return out;
	//return abs(input) > deadzonesize ? ((input - deadzonesize)) : 0; // * 1/(1/deadzonesize)
}

int improveInput(int input) {
  return round(pow(deadzone(input)/128, 3) * 128);
}

//A 91, -105, -471
//B -181, -153, -72
//C -1084, -301, -518
//D -745, -303, -427

void toD() {
	moveTo(baseleft, -745);
	moveTo(midleft, -303);
	moveTo(wrist, -427);
}

void toC() {
	moveTo(baseleft, -1084);
	moveTo(midleft, -301);
	moveTo(wrist, -518);
}

void toB() {
	moveTo(baseleft, -181);
	moveTo(midleft, -153);
	moveTo(wrist, -72);
}

void toA() {
	moveTo(baseleft, 91);
	moveTo(midleft, -105);
	moveTo(wrist, -471);
}

/*********** Main Control ***************/

void pre_auton()
{
  //Place pre-autonomous code here

	slaveMotor(baseright, baseleft);
	slaveMotor(midright, midleft);

  resetMotorEncoder(baseleft);
  resetMotorEncoder(midleft);
  resetMotorEncoder(wrist);
}

task autonomous()
{
  //Place autonomous code here



}

bool started = false;

task usercontrol()
{

	slaveMotor(baseright, baseleft);
	slaveMotor(midright, midleft);

  resetMotorEncoder(baseleft);
  resetMotorEncoder(midleft);
  resetMotorEncoder(wrist);

  while(true) {
  if(vexRT[Btn7U]&&!started) {
  	started=true;
  moveToWait(baseleft, -20);
  moveToWait(midleft, 37);
  moveToWait(baseleft, -341);
  moveToWait(midleft, 50);
  moveToWait(baseleft, -800);
  motor[claw]=127;
	 wait1Msec(120);
	 motor[claw]=0;

	moveToWait(wrist, -440);
}
}

	//moveToWait(midleft, -100);

  while(true) {
  //	motor[baseright]=-motor[baseleft]
  if(vexRT[Btn8L]) {
  	toA();
}
if(vexRT[Btn8D]) {
  	toB();
}
if(vexRT[Btn8R]) {
  	toC();
}
if(vexRT[Btn8U]) {
  	toD();
}

  valb=getMotorEncoder(baseleft);
  valm=getMotorEncoder(midleft);
  valw=getMotorEncoder(wrist);
}

return;

if(true) {
setMotorTarget(baseleft, -20, 127, true);

	// Wait for motor to move
	while(!getMotorTargetCompleted(baseleft)) {
	    wait1Msec(10);
	 }
//val=9999;
setMotorTarget(midleft, 37, 127, true);
	//val=1111;
	// Wait for motor to move
	//while(!getMotorTargetCompleted(midleft)) {
	  //  wait1Msec(10);
	 //}
	 //val=-10000;
	 setMotorTarget(baseleft, -341, 127, true);

	// Wait for motor to move
	//while(!getMotorTargetCompleted(baseleft)) {
	   //wait1Msec(10);
	 //}

	 setMotorTarget(midleft, 50, 127, true);

	// Wait for motor to move
	//while(!getMotorTargetCompleted(midleft)) {
	 //   wait1Msec(10);
	// }
	// while(true) {

//}
	 setMotorTarget(baseleft, -800, 127, true);

	// Wait for motor to move
	//while(!getMotorTargetCompleted(baseleft)) {
	 //   wait1Msec(10);
	 //}
	return;
	wait1Msec(1000*2);
	 motor[claw]=127;
	 wait1Msec(120);
	 motor[claw]=0;

	//val=-123;

	 setMotorTarget(wrist, -440, 127, true);

	 setMotorTarget(midleft, 50, 127, true);

	// Wait for motor to move
	//while(!getMotorTargetCompleted(wrist)) {
	  //  wait1Msec(10);
	 //}

	// setMotorTarget(midleft, -143, 127, true);

	// Wait for motor to move
	//while(!getMotorTargetCompleted(midleft)) {
	  //  wait1Msec(10);
	 //}
}





	while(true) {
	//	val = getMotorEncoder(wrist);
		//datalogAddValue(1, val );
	}



	return;

  int X2 = 0, Y1 = 0, X1 = 0;
  while(true) {
    Y1 = improveInput(vexRT[Ch3]);
    X1 = improveInput(vexRT[Ch4]);
    X2 = improveInput(vexRT[Ch1]);

    // map inputs to mecanum wheels
    motor[frontright] = Y1 - X2 - X1;
    motor[backright] =  Y1 - X2 + X1;
    motor[frontleft] = Y1 + X2 + X1;
    motor[backleft] =  Y1 + X2 - X1;
  }
}
